# 浮点数支持

部分参考自 <https://gitlab.eduxiji.net/retrhelo/xv6-k210/-/blob/scene/doc/%E6%9E%84%E5%BB%BA%E8%B0%83%E8%AF%95-%E6%B5%AE%E7%82%B9%E6%93%8D%E4%BD%9C.md>。

lmbench 中会用到浮点数，因此需要启用浮点数支持，总体包括以下几个部分：

- 初始化时设置 `sstatus` 寄存器中的 `FS` 为 `FS::Initial` 或 `FS::Clean`，以及设置 fcsr 的值（不清楚是不是必须，不过写入 fcsr 也会导致 `FS::Dirty`，所以设置 fcsr 后还要设置为 `FS::Clean`）
- 在合适的时机保存浮点上下文

其中后者可以有很多设计空间：

- 内核态不会使用浮点数，因此用户陷入内核时不是必须保存浮点上下文
- 对于一个任务来说，如果 `FS` 从来不是 `FS::Dirty`，也就是从来没用过浮点数，则既不需要保存也不需要恢复
- 信号处理程序是一个线程内部的多重控制流，其自己的浮点数上下文也需要保存和恢复
- 浮点上下文（可能的）保存时机有两种：任务让出时；进入信号处理时。总之就是 hart 进入新的控制流时
- 对于信号处理程序来说，其旧控制流的恢复时机在 `sys_rt_sigreturn()` 时。
- 如果使用过浮点数，则之后切入任务时都需要恢复浮点上下文

一些优化空间：

- 考虑一个 hart 上的两个任务 A、B，其中 A 使用了浮点数而 B 没有使用。如果运行顺序是 ABA，则其实 A 的上下文是可以不用恢复的。保存可能还是要做，因为运行下一个任务之前并不知道它会不会使用浮点数。具体实现上，思路是：
    - 记录一个 hart 陷入 trap 的次数 `trap_count`（或许也可以是切换控制流次数？），以及其上一次 `FS::Dirty` 时的 `trap_count`，记为 `last_fs_dirty_trap_count`
    - 每个任务记录自己的上一次 `FS::Dirty` 时的 `trap_count`，记为 `last_fs_dirty_trap_count`
    - 当 A 切换到 B 时，如果 `FS::Dirty` 则保存浮点数上下文并更新自己的 `last_fs_dirty_trap_count`
    - 当 B 切换到 A 时，对比 hart 和 A 的 `last_fs_dirty_trap_count`，如果 hart 的更新，则说明在 A 被切出的这段时间有任务使用了浮点数，因此需要恢复 A 的浮点数上下文
- 也许可以让所有任务一开始都不允许使用浮点数。直到其真正使用时出现异常并陷入内核，内核将该任务标记为浮点数任务，并启用浮点数上下文。
- 信号处理时进入新控制流前，旧控制流的上下文会被推到栈上。如果旧控制流没有用过浮点数，则浮点数上下文是可以不保存和恢复的

不过，考虑到安全性问题，其实不应该让不同的任务可以看到其他任务的浮点数。因此即使切入未使用过浮点数任务，也应当将浮点数上下文清空。
